<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <title>牆壁圍棋</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(7, 50px);
            gap: 2px;
        }

        .cell {
            width: 50px;
            height: 50px;
            background: #f0f0f0;
            border: 1px solid #999;
            position: relative;
        }

        .piece {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            position: absolute;
            top: 10px;
            left: 10px;
            cursor: pointer;
        }

        .player1 {
            background: red;
        }

        .player2 {
            background: blue;
        }

        .selected {
            outline: 3px solid gold;
        }

        .wall {
            position: absolute;
            background: black;
            z-index: 1;
        }

        .wall-top {
            height: 4px;
            width: 100%;
            top: 0;
            left: 0;
        }

        .wall-bottom {
            height: 4px;
            width: 100%;
            bottom: 0;
            left: 0;
        }

        .wall-left {
            width: 4px;
            height: 100%;
            top: 0;
            left: 0;
        }

        .wall-right {
            width: 4px;
            height: 100%;
            top: 0;
            right: 0;
        }

        .direction-buttons {
            margin-top: 10px;
        }

        .direction-buttons button {
            margin: 2px;
        }
    </style>
</head>

<body>
    <h1>牆壁圍棋</h1>
    <div id="currentPlayerDisplay">目前玩家：玩家 1（紅）</div>
    <div class="board" id="board"></div>
    <div class="direction-buttons" id="directionButtons" style="display: none">
        <span>設置牆壁方向：</span>
        <button onclick="placeWall('top')">上</button>
        <button onclick="placeWall('bottom')">下</button>
        <button onclick="placeWall('left')">左</button>
        <button onclick="placeWall('right')">右</button>
    </div>
    <div id="scoreBoard" style="margin-top: 10px; font-weight: bold;"></div>
    <div style="margin-top: 10px;">
        <button onclick="restartGame()">重新開始</button>
    </div>
    <script>
        const board = document.getElementById("board");
        const currentPlayerDisplay = document.getElementById("currentPlayerDisplay");
        const scoreBoard = document.getElementById("scoreBoard");
        const size = 7;

        const pieces = {
            player1: [[1, 1], [5, 5]],
            player2: [[5, 1], [1, 5]]
        };

        let placingInitial = true;
        let initialPlaceStep = 0; // 0~3: red -> blue -> blue -> red

        const walls = {};

        let selectedPiece = null;
        let currentPlayer = 1;
        let lastMoved = null;
        let wallPlacedPositions = new Set();

        function key(x, y) {
            return `${x},${y}`;
        }

        function addWall(x, y, dir) {
            const k = key(x, y);
            const uniqueWallKey = `${k}-${dir}`;
            if (wallPlacedPositions.has(uniqueWallKey)) {
                alert("這裡已經放過牆壁了！");
                return false;
            }
            wallPlacedPositions.add(uniqueWallKey);

            if (!walls[k]) walls[k] = new Set();
            walls[k].add(dir);

            const dx = { left: -1, right: 1, top: 0, bottom: 0 }[dir];
            const dy = { left: 0, right: 0, top: -1, bottom: 1 }[dir];
            const opposite = { left: "right", right: "left", top: "bottom", bottom: "top" }[dir];
            const k2 = key(x + dx, y + dy);
            if (!walls[k2]) walls[k2] = new Set();
            walls[k2].add(opposite);
            return true;
        }

        function hasWall(x, y, dir) {
            const k = key(x, y);
            return walls[k]?.has(dir);
        }

        function createCell(x, y) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.x = x;
            cell.dataset.y = y;

            cell.addEventListener("click", () => {
                if (placingInitial) {
                    const playerKey = currentPlayer === 1 ? 'player1' : 'player2';
                    if (!pieces[playerKey].some(([px, py]) => px === x && py === y) &&
                        !pieces.player1.concat(pieces.player2).some(([px, py]) => px === x && py === y)) {
                        pieces[playerKey].push([x, y]);
                        initialPlaceStep++;
                        if (initialPlaceStep === 1) currentPlayer = 2;
                        if (initialPlaceStep === 3) currentPlayer = 1;
                        if (initialPlaceStep >= 4) {
                            placingInitial = false;
                            currentPlayer = 1;
                        }
                        renderBoard();
                    }
                    return;
                }

                if (selectedPiece) {
                    const [px, py] = selectedPiece;
                    const dx = Math.abs(px - x);
                    const dy = Math.abs(py - y);
                    if (dx + dy <= 2 && isValidMove(px, py, x, y)) {
                        movePiece(px, py, x, y);
                        selectedPiece = null;
                        lastMoved = [x, y];
                        renderBoard();
                        document.getElementById("directionButtons").style.display = "block";
                    }
                }
            });

            const k = key(x, y);
            if (walls[k]) {
                for (const dir of walls[k]) {
                    const wallDiv = document.createElement("div");
                    wallDiv.className = `wall wall-${dir}`;
                    cell.appendChild(wallDiv);
                }
            }

            return cell;
        }

        function isValidMove(fromX, fromY, toX, toY) {
            const visited = new Set();
            const queue = [[fromX, fromY, 0]];

            while (queue.length > 0) {
                const [x, y, steps] = queue.shift();
                const k = key(x, y);
                if (k === key(toX, toY)) return true;
                if (steps >= 2) continue;

                for (const [dx, dy, dir] of [[0, -1, 'top'], [0, 1, 'bottom'], [-1, 0, 'left'], [1, 0, 'right']]) {
                    const nx = x + dx, ny = y + dy;
                    const nk = key(nx, ny);
                    if (
                        nx >= 0 && nx < size && ny >= 0 && ny < size &&
                        !hasWall(x, y, dir) &&
                        !visited.has(nk)
                    ) {
                        visited.add(nk);
                        queue.push([nx, ny, steps + 1]);
                    }
                }
            }

            return false;
        }


        /*function renderBoard() {
            board.innerHTML = "";
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const cell = createCell(x, y);

                    [...pieces.player1, ...pieces.player2].forEach(([px, py], index) => {
                        if (px === x && py === y) {
                            const piece = document.createElement("div");
                            const isPlayer1 = index < pieces.player1.length;
                            piece.className = `piece ${isPlayer1 ? "player1" : "player2"}`;
                            if (selectedPiece && selectedPiece[0] === x && selectedPiece[1] === y) {
                                piece.classList.add("selected");
                            }
                            piece.addEventListener("click", (e) => {
                                e.stopPropagation();
                                const owner = isPlayer1 ? 1 : 2;
                                if (owner === currentPlayer && !lastMoved) {
                                    selectedPiece = [x, y];
                                    renderBoard();
                                }
                            });
                            cell.appendChild(piece);
                        }
                    });

                    board.appendChild(cell);
                }
            }
            currentPlayerDisplay.textContent = `目前玩家：玩家 ${currentPlayer}（${currentPlayer === 1 ? '紅' : '藍'}）`;
            return updateScores();
        }*/

        function renderBoard() {
            board.innerHTML = "";
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const cell = createCell(x, y);
                    const k = key(x, y);

                    for (const [px, py] of pieces.player1) {
                        if (px === x && py === y) {
                            const piece = document.createElement("div");
                            piece.className = "piece player1";
                            if (selectedPiece && selectedPiece[0] === x && selectedPiece[1] === y) {
                                piece.classList.add("selected");
                            }
                            piece.addEventListener("click", (e) => {
                                e.stopPropagation();
                                const owner = 1;
                                if (owner === currentPlayer && !lastMoved) {
                                    selectedPiece = [x, y];
                                    renderBoard();
                                }
                            });
                            if (!placingInitial) piece.onclick = () => {
                                if (currentPlayer === 1) {
                                    selectedPiece = [x, y];
                                    renderBoard();
                                }
                            };
                            cell.appendChild(piece);
                        }
                    }

                    for (const [px, py] of pieces.player2) {
                        if (px === x && py === y) {
                            const piece = document.createElement("div");
                            piece.className = "piece player2";
                            if (selectedPiece && selectedPiece[0] === x && selectedPiece[1] === y) {
                                piece.classList.add("selected");
                            }
                            piece.addEventListener("click", (e) => {
                                e.stopPropagation();
                                const owner = 2;
                                if (owner === currentPlayer && !lastMoved) {
                                    selectedPiece = [x, y];
                                    renderBoard();
                                }
                            });
                            if (!placingInitial) piece.onclick = () => {
                                if (currentPlayer === 2) {
                                    selectedPiece = [x, y];
                                    renderBoard();
                                }
                            };
                            cell.appendChild(piece);
                        }
                    }

                    board.appendChild(cell);
                }
            }
            currentPlayerDisplay.textContent = placingInitial
                ? `請玩家 ${currentPlayer} 放置棋子`
                : `目前玩家：玩家 ${currentPlayer}（${currentPlayer === 1 ? '紅' : '藍'}）`;
            return updateScores();
        }

        function movePiece(fromX, fromY, toX, toY) {
            let list = currentPlayer === 1 ? pieces.player1 : pieces.player2;
            let index = list.findIndex(([px, py]) => px === fromX && py === fromY);
            if (index !== -1) {
                list[index] = [toX, toY];
            }
        }

        function floodFill(x, y, visited) {
            const queue = [[x, y]];
            const startKey = key(x, y);
            visited.add(startKey);
            while (queue.length > 0) {
                const [cx, cy] = queue.shift();
                for (const [dx, dy, dir] of [[0, -1, 'top'], [0, 1, 'bottom'], [-1, 0, 'left'], [1, 0, 'right']]) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size && !hasWall(cx, cy, dir)) {
                        const k = key(nx, ny);
                        if (!visited.has(k)) {
                            visited.add(k);
                            queue.push([nx, ny]);
                        }
                    }
                }
            }
        }

        function updateScores() {
            const visited = new Set();
            const areaScores = { player1: 0, player2: 0 };
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const k = key(x, y);
                    if (!visited.has(k)) {
                        const region = new Set();
                        floodFill(x, y, region);
                        region.forEach(pos => visited.add(pos));
                        const p1Count = [...pieces.player1].filter(([px, py]) => region.has(key(px, py))).length;
                        const p2Count = [...pieces.player2].filter(([px, py]) => region.has(key(px, py))).length;
                        if (p1Count > 0 && p2Count === 0) areaScores.player1 += region.size;
                        else if (p2Count > 0 && p1Count === 0) areaScores.player2 += region.size;
                    }
                }
            }
            scoreBoard.textContent = `玩家 1 得分：${areaScores.player1}；玩家 2 得分：${areaScores.player2}`;
            return [areaScores.player1, areaScores.player2];
        }

        function checkGameOver(player1_score, player2_score) {
            const allPieces = [...pieces.player1, ...pieces.player2];
            const visited = new Set();
            const groups = [];

            for (const [px, py] of allPieces) {
                const k = key(px, py);
                if (!visited.has(k)) {
                    const groupVisited = new Set();
                    floodFill(px, py, groupVisited);
                    groups.push([...groupVisited].filter(pos => allPieces.some(([gx, gy]) => key(gx, gy) === pos)));
                    groupVisited.forEach(pos => visited.add(pos));
                }
            }

            const totalPieces = allPieces.length;
            const totalGroupedPieces = groups.reduce((acc, g) => acc + g.length, 0);

            if (groups.length === totalPieces && totalGroupedPieces === totalPieces) {
                if (player1_score > player2_score) alert("遊戲結束！紅色獲勝。");
                else if (player2_score > player1_score) alert("遊戲結束！藍色獲勝。");
                else alert("遊戲結束！雙方平手。");
            }
        }

        function restartGame() {
            pieces.player1 = [];
            pieces.player2 = [];
            initialPlacingIndex = 0;
            currentPlayer = initialPlacement[0].player;
            placingInitial = true;
            selectedPiece = null;
            lastMoved = null;
            wallPlacedPositions.clear();
            for (const key in walls) delete walls[key];
            renderBoard();
            currentPlayerDisplay.textContent = "目前玩家：玩家 1（紅）";
            scoreBoard.textContent = "";
            document.getElementById("directionButtons").style.display = "none";
        }

        window.placeWall = function (dir) {
            if (!lastMoved) return;
            const [x, y] = lastMoved;
            const placed = addWall(x, y, dir);
            if (!placed) return;
            document.getElementById("directionButtons").style.display = "none";
            lastMoved = null;
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            const [player1_score, player2_score] = renderBoard();
            checkGameOver(player1_score, player2_score);
        };

        renderBoard();
    </script>
</body>

</html>
